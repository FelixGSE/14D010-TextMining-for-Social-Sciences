set.seed(1)
# Compute states
for( k in 2:N ){
u.temp <- L %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(w)
}
# Return states
return(x)
}
rigati.states()
rigati.states <- function(  N  = 100,
x0 = c(1,1),
D  = diag(2),
R  = diag(2) * c( 1, 2 ) ,
A  = matrix( sample(6,4,replace=TRUE), 2, 2),
B  = matrix( sample(6,4,replace=TRUE), 2, 2),
C  = c( 1, 1 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize matrices
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K <- list()
K[[N]]  <- Q
# Compute K and L matrices
for ( k in (N-1):1 ){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
if( sum( ( K[[k]] - K[[(k+1)]] ) ) < 10**(-6) ){
K <- K[[(k+1)]]
print(K)
break
}
}
L <- - solve( t(B) %*% K  %*% B + R) %*% t(B) %*% K %*% A
set.seed(1)
# Compute states
for( k in 2:N ){
u.temp <- L %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(w)
}
# Return states
return(x)
}
rigati.states()
mu      <- c( 0 , 0 )
D
D  = diag(2) * c(0.5,0.2)
w      <- rmvnorm( 100 , mean = mu , sigma = D )
if (!require("mvtnorm")) install.packages("mvtnorm"); library(mvtnorm)
w      <- rmvnorm( 100 , mean = mu , sigma = D )
w
w[[1]]
w[1,]
t(w[1,])
compute.states <- function(  N  = 100,
x0 = c(3,2),
D  = diag(2) * c(0.5,0.2),
R  = diag(2) * c( 2, 1 ) ,
A  = matrix( c(0,3,0,0), 2, 2),
B  = matrix( c(4,2,0,1), 2, 2),
C  = c( 5, 0 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(AM(w[(k-1),]))
}
compute.states <- function(  N  = 100,
x0 = c(3,2),
D  = diag(2) * c(0.5,0.2),
R  = diag(2) * c( 2, 1 ) ,
A  = matrix( c(0,3,0,0), 2, 2),
B  = matrix( c(4,2,0,1), 2, 2),
C  = c( 5, 0 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(AM(w[(k-1),]))
}
}
compute.states <- function(  N  = 100,
x0 = c(3,2),
D  = diag(2) * c(0.5,0.2),
R  = diag(2) * c( 2, 1 ) ,
A  = matrix( c(0,3,0,0), 2, 2),
B  = matrix( c(4,2,0,1), 2, 2),
C  = c( 5, 0 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(AM(w[(k-1),]))
}
}
}
compute.states <- function(  N  = 100,
x0 = c(3,2),
D  = diag(2) * c(0.5,0.2),
R  = diag(2) * c( 2, 1 ) ,
A  = matrix( c(0,3,0,0), 2, 2),
B  = matrix( c(4,2,0,1), 2, 2),
C  = c( 5, 0 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(AM(w[(k-1),]))
}
}
compute.states
compute.states()
compute.states <- function(  N  = 100,
x0 = c(3,2),
D  = diag(2) * c(0.5,0.2),
R  = diag(2) * c( 2, 1 ) ,
A  = matrix( c(0,3,0,0), 2, 2),
B  = matrix( c(4,2,0,1), 2, 2),
C  = c( 5, 0 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + AM(w[(k-1),])
}
}
compute.states()
N  = 100
x0 = c(3,2)
D  = diag(2) * c(0.5,0.2)
R  = diag(2) * c( 2, 1 )
A  = matrix( c(0,3,0,0), 2, 2)
B  = matrix( c(4,2,0,1), 2, 2)
C  = c( 5, 0 )
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + AM(w[(k-1),])
}
w
w      <- rmvnorm( 100 , mean = mu , sigma = D )
w
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
N  = 100
x0 = c(3,2)
D  = diag(2) * c(0.5,0.2)
R  = diag(2) * c( 2, 1 )
A  = matrix( c(0,3,0,0), 2, 2)
B  = matrix( c(4,2,0,1), 2, 2)
C  = c( 5, 0 )
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + AM(w[(k-1),])
}
}
compute.states()
N  = 100
x0 = c(3,2)
D  = diag(2) * c(0.5,0.2)
R  = diag(2) * c( 2, 1 )
A  = matrix( c(0,3,0,0), 2, 2)
B  = matrix( c(4,2,0,1), 2, 2)
C  = c( 5, 0 )
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + AM(w[(k-1),])
}
}
compute.states()
w      <- rmvnorm( 100 , mean = mu , sigma = D )
w
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + AM(w[(k-1),])
}
x
matrix( c(0,3,0,0), 2, 2)
matrix( c(4,2,0,1), 2, 2)
install.packages("TMVA")
100000000*1000
100000000*1000
setwd('/Users/felix/Documents/GSE/Term 3/14D009 Social and Economic/Networks/Problemsets/14D009-Social-and-Economic-Networks/')
set.seed(1,2,3)
set.seed(123)
runif(1)
pnorm(100)
pnorm(1)
pnorm(c(1,23))
pnorm(rnorm(100))
plot(pnorm(rnorm(10000)))
if (!require("RColorBrewer")) install.packages("RColorBrewer");
brewer.pal(7,"RdBU")
PRGn
brewer.pal(7,"PRGn")
brewer.pal(100,"PRGn")
colorRampPalette(brewer.pal(9,"Reds"))(100)
reds  <- colorRampPalette(brewer.pal(9,"Reds"))(11)
blues <- colorRampPalette(brewer.pal(9,"Blues"))(11)
diverging.colors <- c(reds,blues)
diverging.colors
library('igraph')
erdos.renyi.game(20, p=0.4, directed = FALSE, loops = FALSE)
union(g01,g02)
g01 <- erdos.renyi.game(20, p=0.4, directed = FALSE, loops = FALSE)
g02 <- erdos.renyi.game(20, p=0.4, directed = FALSE, loops = FALSE)
union(g01,g02)
0.2*40
.15*40
6/40
plot(g03)
g03 <- union(g01,g02)
plot(g03)
15/40
rewire.edges(graph, p=15/40, loops=FALSE, multiple=FALSE)
rewire.edges(g03, p=15/40, loops=FALSE, multiple=FALSE)
library('igraph')
rewire(g03, p=15/40, loops=FALSE, multiple=FALSE)
rewire(g03, each_edge(prob = 0.05), loops=FALSE, multiple=FALSE)
rewire(g03, each_edge(prob = 0.05))
g03 <- rewire( union(g01,g02), each_edge(prob = 0.05))
plot(g03)
edge.betweenness.community(g03)
modularity(g03)
GN <- edge.betweenness.community(g03)
modularity(g, membership(GN))
modularity(g03, membership(GN))
MM <- optimal.community(g03, weights = NULL)
GGM
GM
MM <- optimal.community(g03, weights = NULL)
MM
g03 <- rewire( intersect(g01,g02), each_edge(prob = 0.05))
g03 <- rewire( union(g01,g02), each_edge(prob = 0.05))
V(g01)$name
V(g01)$name <- 21:40
V(g01)$name
g01 <- erdos.renyi.game(20, p=0.4, directed = FALSE, loops = FALSE)
g02 <- erdos.renyi.game(20, p=0.4, directed = FALSE, loops = FALSE)
g03 <- rewire( union(g01,g02), each_edge(prob = 0.05))
plot(g03)
plot(g01)
V(g01)$name <- 0:20
V(g01)$name <- 1:20
V(g02)$name <- 21:40
# Merge graphs and rewire edges
g03 <- rewire( union(g01,g02), each_edge(prob = 0.05))
g02
plot(g02)
g03 <- rewire( union(g01,g02), each_edge(prob = 0.05))
g03 <- rewire( c(g01,g02), each_edge(prob = 0.05))
g03 <- rewire( g01, each_edge(prob = 0.05))
plot(g01)
union(g01,g02)
class(g02)
union(g01,g02)
g01 <- erdos.renyi.game(20, p=0.4, directed = FALSE, loops = FALSE)
g02 <- erdos.renyi.game(20, p=0.4, directed = FALSE, loops = FALSE)
union(g01,g02)
V(g01)$name <- paste(1:20)
plot(g01)
paste(1:20)
V(g02)$name <- paste(21:40)
g03 <- rewire( union(g01,g02), each_edge(prob = 0.05))
plot(g03)
plot(g01)
plot(g03)
cg <- contract.vertices(g03, membership(GN))
GN
GN <- edge.betweenness.community(g03)
cg <- contract.vertices(g03, membership(GN))
E(cg)$weight <- 1
cg2 <- simplify(cg, remove.loops=FALSE)
## Plot the community graph
plot(cg2, edge.label=E(cg2)$weight, margin=.5, layout=layout.circle)
GN
cg <- contract.vertices(g03, membership(GN))
plot(cg2, margin=.5, layout=layout.circle)
plot(cg, margin=.5, layout=layout.circle)
plot(g03,col=memberhsip(GN))
plot(g03,col=membership(GN))
plot(GN, g03, layout=coords)
coords <- crossing(GN, g03)
plot(GN, g03, layout=coords)
plot(GN, g03, layout=layout_with_fr(g03))
g03 <- rewire( union(g01,g02), each_edge(prob = 15/40))
GN <- edge.betweenness.community(g03)
MM <- optimal.community(g03, weights = NULL)
GN <- edge.betweenness.community(g03)
MM <- optimal.community(g03)
plot(GN, g03, layout=layout_with_fr(g03))
# (1) - Create two random undirected graphs with p=0.4 and 20 nodes
g01 <- erdos.renyi.game(20, p=0.4, directed = FALSE, loops = FALSE)
g02 <- erdos.renyi.game(20, p=0.4, directed = FALSE, loops = FALSE)
V(g01)$name <- paste(1:20)
V(g02)$name <- paste(21:40)
GN <- edge.betweenness.community(g03)
plot(GN, g03, layout=layout_with_fr(g03))
GN
15/40
ecount(g03)
p <- 15/ecount(g03)
g03 <- rewire( union(g01,g02), each_edge(prob = p))
GN <- edge.betweenness.community(g03)
MM <- optimal.community(g03)
plot(GN, g03, layout=layout_with_fr(g03))
p
plot(MM, g03, layout=layout_with_fr(g03))
plot(GN, g03, layout=layout.start(g03))
plot(GN, g03, layout=layout.star(g03))
plot(GN, g03, layout=layout.nicely(g03))
plot(GN, g03, layout=layout_nicely(g03))
dendPlot(GN)
dendPlot(MM)
dendPlot(GN)
plot(GN, g03, layout=layout_nicely(g03),col=c('red','blue'))
plot(GN, g03, layout=layout_nicely(g03),mark.groups=c('red','blue'))
plot(GN, g03, layout=layout_nicely(g03),mark.groups('red','blue'))
plot(GN, g03, layout=layout_nicely(g03),groups('red','blue'))
plot(GN, g03, layout=layout_nicely(g03),col=c('red','b'))
plot(GN, g03, layout=layout_nicely(g03))
plot(GN, g03, layout=layout_nicely(g03),mark.col=c("#C5E5E7","#ECD89A"), mark.border=NA)
pers.blue
### Styling options
co <- 1/255
pers.green      <- rgb( co *  14 ,  co * 105 , co *  90 )
pers.blue       <- rgb( co *  22 ,  co *  54 , co *  92 )
pers.red        <- rgb( co *  99 ,  co *  37 , co *  35 )
pers.gray       <- rgb( co * 150 ,  co * 150 , co * 150 )
pers.orange     <- rgb( co * 186 ,  co *  85 , co *  59 )
pers.beige      <- rgb( co * 196 ,  co * 189 , co * 151 )
pers.blue
plot(GN, g03, layout=layout_nicely(g03),mark.col=c(pers.blue,pers.green), mark.border=NA)
plot(GN, g03, layout=layout_nicely(g03),mark.col=c(pers.blue,pers.green,alpha = 0.3), mark.border=NA)
plot(GN, g03, layout=layout_nicely(g03),mark.col=c(pers.blue,pers.green),alpha = 0.3, mark.border=NA)
plot(GN, g03, layout=layout_nicely(g03),mark.col=c("#C5E5E7","#ECD89A"), mark.border=NA)
colorRampPalette(brewer.pal(9,”Blues”))(100)
library('RColorBrewer')
colorRampPalette(brewer.pal(9,”Blues”))(100)
colorRampPalette(brewer.pal(9,"Blues"))(100)
plot(GN, g03, layout=layout_nicely(g03),mark.col=c("#F0F7FD","#ECD89A"), mark.border=NA)
plot(GN, g03, layout=layout_nicely(g03),mark.col=c("#B5D3E9","#ECD89A"), mark.border=NA)
colorRampPalette(brewer.pal(9,"Greens"))(100)
plot(GN, g03, layout=layout_nicely(g03),mark.col=c("#B5D3E9","#B6E2B0"), mark.border=NA)
plot(GN, g03, layout=layout_nicely(g03),mark.col=c("#B5D3E9","#B6E2B0"), mark.border=TRUE)
plot(GN, g03, layout=layout_nicely(g03),mark.col=c("#B5D3E9","#B6E2B0"), mark.border=c('black','black'))
plot(MM, g03, layout=layout_with_fr(g03),mark.col=c("#B5D3E9","#B6E2B0"), mark.border=c('black','black'))
dendPlot(GN)
plot(GN, g03, layout=layout_nicely(g03),mark.col=c('black',"#B6E2B0"), ark.border=c('black','black'))
plot(GN, g03, layout=layout_nicely(g03),mark.col=c('black',"#B6E2B0"), mark.border=c('black','black'))
plot(GN, g03, layout=layout_nicely(g03),mark.col=c('black','black'), mark.border=c('black','black'))
"#B5D3E9"
plot(GN, g03, layout=layout_nicely(g03),mark.col=c("#B5D3E9","#B6E2B0"), mark.border=c('black','black'))
setwd('~/Users/felix/Documents/GSE/Term 3/14D010 Text Mining for Social Sciences/14D010-TextMining-for-Social-Sciences/Project/Project/')
setwd('~/Users/felix/Documents/GSE/Term 3/14D010 Text Mining for Social Sciences/14D010-TextMining-for-Social-Sciences/Project/')
setwd('~/Users/felix/Documents/GSE/Term 3/14D010 Text Mining for Social Sciences/14D010-TextMining-for-Social-Sciences/Project')
getwd()
setwd('~/Users/felix/Documents/GSE/Term 3/14D010 Text Mining for Social Sciences/14D010-TextMining-for-Social-Sciences/Project')
################################################################################
# Preamble
################################################################################
### Clear workspace
rm(list = ls())
### Set general file path
setwd('~/Users/felix/Documents/GSE/Term 3/14D010 Text Mining for Social Sciences/14D010-TextMining-for-Social-Sciences/Project')
setwd('~/Users/felix/Documents/GSE/Term 3/14D010 Text Mining for Social Sciences/14D010-TextMining-for-Social-Sciences/')
setwd('~/Users/felix/Documents/GSE/Term 3/14D010 Text Mining for Social Sciences/')
setwd('/Users/felix/Documents/GSE/Term 3/14D010 Text Mining for Social Sciences/14D010-TextMining-for-Social-Sciences/Project')
setwd('~/Documents/GSE/Term 3/14D010 Text Mining for Social Sciences/14D010-TextMining-for-Social-Sciences/Project/')
if (!require("nnet")) install.packages("nnet"); library(nnet)
setwd('TeX/TeX/Pictures/')
getwd()
setwd('/TeX/TeX/Pictures/')
setwd('/TeX/Pictures/')
setwd('TeX/Pictures/')
setwd('~/Documents/GSE/Term 3/14D010 Text Mining for Social Sciences/14D010-TextMining-for-Social-Sciences/Project/')
read.csv('frame.csv')
full.data <- read.csv('frame.csv')
dim(full.data)
